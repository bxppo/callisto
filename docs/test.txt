Overview

A thread is a basic unit of CPU utilization; it comprises a thread ID, a program
counter, a register set, and a stack. It shares with other threads belonging
to the same process its code section, data section, and other operating-system
resources, such as open files and signals. A traditional (or heavyweight) process
has a single thread of control. If a process has multiple threads of control, it
can perform more than one task at a time. Figure 4.1 illustrates the difference
between a traditional single-threaded process and a multithreaded process

Motivation

Most software applications that run on modern computers are multithreaded.
An application typically is implemented as a separate process with several
threads of control. A web browser might have one thread display images or
text while another thread retrieves data from the network, for example. A
word processor may have a thread for displaying graphics, another thread for
responding to keystrokes from the user, and a third thread for performing
spelling and grammar checking in the background. Applications can also
be designed to leverage processing capabilities on multicore systems. Such
applications can perform several CPU-intensive tasks in parallel across the
multiple computing cores.
In certain situations, a single application may be required to perform
several similar tasks. For example, a web server accepts client requests for
web pages, images, sound, and so forth. A busy web server may have several
(perhaps thousands of) clients concurrently accessing it. If the web server ran
as a traditional single-threaded process, it would be able to service only one
client at a time, and a client might have to wait a very long time for its request
to be serviced.
One solution is to have the server run as a single process that accepts
requests. When the server receives a request, it creates a separate process
to service that request. In fact, this process-creation method was in common
use before threads became popular. Process creation is time consuming and
resource intensive, however. If the new process will perform the same tasks as
the existing process, why incur all that overhead? It is generally more efficient
to use one process that contains multiple threads. If the web-server process is
multithreaded, the server will create a separate thread that listens for client
requests. When a request is made, rather than creating another process, the
server creates a new thread to service the request and resume listening for
additional requests. This is illustrated in Figure 4.2.
Threads also play a vital role in remote procedure call (RPC) systems. Recall
from Chapter 3 that RPCs allow interprocess communication by providing a
communication mechanism similar to ordinary function or procedure calls.
Typically, RPC servers are multithreaded. When a server receives a message, it
services the message using a separate thread. This allows the server to service
several concurrent requests.
Finally, most operating-system kernels are now multithreaded. Several
threads operate in the kernel, and each thread performs a specific task, such
as managing devices, managing memory, or interrupt handling. For example,
Solaris has a set of threads in the kernel specifically for interrupt handling;
Linux uses a kernel thread for managing the amount of free memory in the
system.

Benefits

The benefits of multithreaded programming can be broken down into four
major categories:
Responsiveness. Multithreading an interactive application may allow
a program to continue running even if part of it is blocked or is
performing a lengthy operation, thereby increasing responsiveness to
the user. This quality is especially useful in designing user interfaces. For
instance, consider what happens when a user clicks a button that results
in the performance of a time-consuming operation. A single-threaded
application would be unresponsive to the user until the operation had
completed. In contrast, if the time-consuming operation is performed in
a separate thread, the application remains responsive to the user.
2. Resource sharing. Processes can only share resources through techniques
such as shared memory and message passing. Such techniques must
be explicitly arranged by the programmer. However, threads share the
memory and the resources of the process to which they belong by default.
The benefit of sharing code and data is that it allows an application to
have several different threads of activity within the same address space.
3. Economy. Allocating memory and resources for process creation is costly.
Because threads share the resources of the process to which they belong,
it is more economical to create and context-switch threads. Empirically
gauging the difference in overhead can be difficult, but in general it is
significantly more time consuming to create and manage processes than
threads. In Solaris, for example, creating a process is about thirty times
slower than is creating a thread, and context switching is about five times slower.
4. Scalability. The benefits of multithreading can be even greater in a
multiprocessor architecture, where threads may be running in parallel
on different processing cores. A single-threaded process can run on only
one processor, regardless how many are available. We explore this issue
further in the following section.

Multicore Programming

Earlier in the history of computer design, in response to the need for more
computing performance, single-CPU systems evolved into multi-CPU systems.
A more recent, similar trend in system design is to place multiple computing
cores on a single chip. Each core appears as a separate processor to the
operating system (Section 1.3.2). Whether the cores appear across CPU chips or
within CPU chips, we call these systems multicore or multiprocessor systems.
Multithreaded programming provides a mechanism for more efficient use
of these multiple computing cores and improved concurrency. Consider an
application with four threads. On a system with a single computing core,
concurrency merely means that the execution of the threads will be interleaved
over time (Figure 4.3), because the processing core is capable of executing only
one thread at a time. On a system with multiple cores, however, concurrency
means that the threads can run in parallel, because the system can assign a
separate thread to each core (Figure 4.4).
Notice the distinction between parallelism and concurrency in this discussion. A system is parallel if it can perform more than one task simultaneously.
In contrast, a concurrent system supports more than one task by allowing all
the tasks to make progress. Thus, it is possible to have concurrency without
parallelism. Before the advent of SMP and multicore architectures, most computer systems had only a single processor. CPU schedulers were designed to
provide the illusion of parallelism by rapidly switching between processes in
The trend towards multicore systems continues to place pressure on system
designers and application programmers to make better use of the multiple
computing cores. Designers of operating systems must write scheduling
algorithms that use multiple processing cores to allow the parallel execution
shown in Figure 4.4. For application programmers, the challenge is to modify
existing programs as well as design new programs that are multithreaded.
In general, five areas present challenges in programming for multicore
systems.1. Identifying tasks. This involves examining applications to find areas
that can be divided into separate, concurrent tasks. Ideally, tasks are
independent of one another and thus can run in parallel on individual
cores.
2. Balance. While identifying tasks that can run in parallel, programmers
must also ensure that the tasks perform equal work of equal value. In
some instances, a certain task may not contribute as much value to the
overall process as other tasks. Using a separate execution core to run that
task may not be worth the cost.
3. Data splitting. Just as applications are divided into separate tasks, the
data accessed and manipulated by the tasks must be divided to run on
separate cores.
4. Data dependency. The data accessed by the tasks must be examined for
dependencies between two or more tasks. When one task depends on
data from another, programmers must ensure that the execution of the
tasks is synchronized to accommodate the data dependency. We examine
such strategies in Chapter 5.
5. Testing and debugging. When a program is running in parallel on
multiple cores, many different execution paths are possible. Testing and
debugging such concurrent programs is inherently more difficult than
testing and debugging single-threaded applications.
Because of these challenges, many software developers argue that the advent of
multicore systems will require an entirely new approach to designing software
systems in the future. (Similarly, many computer science educators believe that
software development must be taught with increased emphasis on parallel
programming.)

Types of Parallelism

In general, there are two types of parallelism: data parallelism and task
parallelism. Data parallelism focuses on distributing subsets of the same data
across multiple computing cores and performing the same operation on each
core. Consider, for example, summing the contents of an array of size N. On a
single-core system, one thread would simply sum the elements [0] . . . [N − 1].
On a dual-core system, however, thread A, running on core 0, could sum the
elements [0] . . . [N/2 − 1] while thread B, running on core 1, could sum the
elements [N/2] . . . [N − 1]. The two threads would be running in parallel on
separate computing cores.
Task parallelism involves distributing not data but tasks (threads) across
multiple computing cores. Each thread is performing a unique operation.
Different threads may be operating on the same data, or they may be operating
on different data. Consider again our example above. In contrast to that
situation, an example of task parallelism might involve two threads, each
performing a unique statistical operation on the array of elements. The threads
again are operating in parallel on separate computing cores, but each is
performing a unique operation
Fundamentally, then, data parallelism involves the distribution of data
across multiple cores and task parallelism on the distribution of tasks across
multiple cores. In practice, however, few applications strictly follow either data
or task parallelism. In most instances, applications use a hybrid of these two
strategies

Multithreading Models

Our discussion so far has treated threads in a generic sense. However, support
for threads may be provided either at the user level, for user threads, or by the
kernel, for kernel threads. User threads are supported above the kernel and
are managed without kernel support, whereas kernel threads are supported
and managed directly by the operating system. Virtually all contemporary
operating systems—including Windows, Linux, Mac OS X, and Solaris—
support kernel threads.
Ultimately, a relationship must exist between user threads and kernel
threads. In this section, we look at three common ways of establishing such a
relationship: the many-to-one model, the one-to-one model, and the many-tomany model

Many-to-One Model

The many-to-one model (Figure 4.5) maps many user-level threads to one
kernel thread. Thread management is done by the thread library in user space,
so it is efficient (we discuss thread libraries in Section 4.4). However, the entire
process will block if a thread makes a blocking system call. Also, because only
one thread can access the kernel at a time, multiple threads are unable to run in
parallel on multicore systems. Green threads—a thread library available for
Solaris systems and adopted in early versions of Java—used the many-to-one
model. However, very few systems continue to use the model because of its
inability to take advantage of multiple processing cores

One-to-One Model

The one-to-one model (Figure 4.6) maps each user thread to a kernel thread. It
provides more concurrency than the many-to-one model by allowing another
thread to run when a thread makes a blocking system call. It also allows
multiple threads to run in parallel on multiprocessors. The only drawback to
this model is that creating a user thread requires creating the corresponding
kernel thread. Because the overhead of creating kernel threads can burden the
performance of an application, most implementations of this model restrict the
number of threads supported by the system. Linux, along with the family of
Windows operating systems, implement the one-to-one model.

Many-to-Many Model

The many-to-many model (Figure 4.7) multiplexes many user-level threads to
a smaller or equal number of kernel threads. The number of kernel threads
may be specific to either a particular application or a particular machine (an
application may be allocated more kernel threads on a multiprocessor than on
a single processor).
Let’s consider the effect of this design on concurrency. Whereas the manyto-one model allows the developer to create as many user threads as she wishes,
it does not result in true concurrency, because the kernel can schedule only
one thread at a time. The one-to-one model allows greater concurrency, but the
developer has to be careful not to create too many threads within an application
(and in some instances may be limited in the number of threads she can
reate). The many-to-many model suffers from neither of these shortcomings:
developers can create as many user threads as necessary, and the corresponding
kernel threads can run in parallel on a multiprocessor. Also, when a thread
performs a blocking system call, the kernel can schedule another thread for
execution.
One variation on the many-to-many model still multiplexes many userlevel threads to a smaller or equal number of kernel threads but also allows a
user-level thread to be bound to a kernel thread. This variation is sometimes
referred to as the two-level model (Figure 4.8). The Solaris operating system
supported the two-level model in versions older than Solaris 9. However,
beginning with Solaris 9, this system uses the one-to-one model.

Thread Libraries

A thread library provides the programmer with an API for creating and
managing threads. There are two primary ways of implementing a thread
library. The first approach is to provide a library entirely in user space with no
kernel support. All code and data structures for the library exist in user space.
This means that invoking a function in the library results in a local function
call in user space and not a system call.
The second approach is to implement a kernel-level library supported
directly by the operating system. In this case, code and data structures for
the library exist in kernel space. Invoking a function in the API for the library
typically results in a system call to the kernel.
Three main thread libraries are in use today: POSIX Pthreads, Windows, and
Java. Pthreads, the threads extension of the POSIX standard, may be provided
as either a user-level or a kernel-level library. The Windows thread library
is a kernel-level library available on Windows systems. The Java thread API
allows threads to be created and managed directly in Java programs. However,
because in most instances the JVM is running on top of a host operating system,
the Java thread API is generally implemented using a thread library available
on the host system. This means that on Windows systems, Java threads are
typically implemented using the Windows API; UNIX and Linux systems often
use Pthreads
For POSIX and Windows threading, any data declared globally—that is,
declared outside of any function—are shared among all threads belonging to
the same process. Because Java has no notion of global data, access to shared
data must be explicitly arranged between threads. Data declared local to a
function are typically stored on the stack. Since each thread has its own stack,
each thread has its own copy of local data.
In the remainder of this section, we describe basic thread creation using
these three thread libraries. As an illustrative example, we design a multithreaded program that performs the summation of a non-negative integer in a
separate thread using the well-known summation function:
For example, if N were 5, this function would represent the summation of
integers from 0 to 5, which is 15. Each of the three programs will be run with
the upper bounds of the summation entered on the command line. Thus, if the
user enters 8, the summation of the integer values from 0 to 8 will be output.
Before we proceed with our examples of thread creation, we introduce
two general strategies for creating multiple threads: asynchronous threading
and synchronous threading. With asynchronous threading, once the parent
creates a child thread, the parent resumes its execution, so that the parent
and child execute concurrently. Each thread runs independently of every other
thread, and the parent thread need not know when its child terminates. Because
the threads are independent, there is typically little data sharing between
threads. Asynchronous threading is the strategy used in the multithreaded
server illustrated in Figure 4.2.
Synchronous threading occurs when the parent thread creates one or more
children and then must wait for all of its children to terminate before it resumes
—the so-called fork-join strategy. Here, the threads created by the parent
perform work concurrently, but the parent cannot continue until this work
has been completed. Once each thread has finished its work, it terminates
and joins with its parent. Only after all of the children have joined can the
parent resume execution. Typically, synchronous threading involves significant
data sharing among threads. For example, the parent thread may combine the
results calculated by its various children. All of the following examples use
synchronous threading.

Pthreads

Pthreads refers to the POSIX standard (IEEE 1003.1c) defining an API for thread
creation and synchronization. This is a specification for thread behavior,
not an implementation. Operating-system designers may implement the
specification in any way they wish. Numerous systems implement the Pthreads
specification; most are UNIX-type systems, including Linux, Mac OS X, and
Solaris. Although Windows doesn’t support Pthreads natively, some thirdparty implementations for Windows are available.
The C program shown in Figure 4.9 demonstrates the basic Pthreads API for
constructing a multithreaded program that calculates the summation of a nonnegative integer in a separate thread. In a Pthreads program, separate threads
#include <pthread.h>
#include <stdio.h>
int sum; /* this data is shared by the thread(s) */
void *runner(void *param); /* threads call this function */
int main(int argc, char *argv[])
{
pthread t tid; /* the thread identifier */
pthread attr t attr; /* set of thread attributes */
if (argc != 2) {
fprintf(stderr,"usage: a.out <integer value>\n");
return -1;
}
if (atoi(argv[1]) < 0) {
fprintf(stderr,"%d must be >= 0\n",atoi(argv[1]));
return -1;
}
/* get the default attributes */
pthread attr init(&attr);
/* create the thread */
pthread create(&tid,&attr,runner,argv[1]);
/* wait for the thread to exit */
pthread join(tid,NULL);
printf("sum = %d\n",sum);
}
/* The thread will begin control in this function */
void *runner(void *param)
{
int i, upper = atoi(param);
sum = 0;
for (i = 1; i <= upper; i++)
sum += i;
pthread exit(0);
}
begin execution in a specified function. In Figure 4.9, this is the runner()
function. When this program begins, a single thread of control begins in
main(). After some initialization, main() creates a second thread that begins
control in the runner() function. Both threads share the global data sum.
Let’s look more closely at this program. All Pthreads programs must
include the pthread.h header file. The statement pthread t tid declares
#define NUM THREADS 10
/* an array of threads to be joined upon */
pthread t workers[NUM THREADS];
for (int i = 0; i < NUM THREADS; i++)
pthread join(workers[i], NULL);
the identifier for the thread we will create. Each thread has a set of attributes,
including stack size and scheduling information. The pthread attr t attr
declaration represents the attributes for the thread. We set the attributes in the
function call pthread attr init(&attr). Because we did not explicitly set
any attributes, we use the default attributes provided. (In Chapter 6, we discuss
some of the scheduling attributes provided by the Pthreads API.) A separate
thread is created with the pthread create() function call. In addition to
passing the thread identifier and the attributes for the thread, we also pass the
name of the function where the new thread will begin execution—in this case,
the runner() function. Last, we pass the integer parameter that was provided
on the command line, argv[1].
At this point, the program has two threads: the initial (or parent) thread
in main() and the summation (or child) thread performing the summation
operation in the runner() function. This program follows the fork-join strategy
described earlier: after creating the summation thread, the parent thread
will wait for it to terminate by calling the pthread join() function. The
summation thread will terminate when it calls the function pthread exit().
Once the summation thread has returned, the parent thread will output the
value of the shared data sum.
This example program creates only a single thread. With the growing
dominance of multicore systems, writing programs containing several threads
has become increasingly common. A simple method for waiting on several
threads using the pthread join() function is to enclose the operation within
a simple for loop. 

Windows Threads

The technique for creating threads using the Windows thread library is similar
to the Pthreads technique in several ways. We illustrate the Windows thread
API in the C program shown in Figure 4.11. Notice that we must include the
windows.h header file when using the Windows API.
Just as in the Pthreads version shown in Figure 4.9, data shared by the
separate threads—in this case, Sum—are declared globally (the DWORD data
type is an unsigned 32-bit integer). We also define the Summation() function
that is to be performed in a separate thread. This function is passed a pointer
to a void, which Windows defines as LPVOID. The thread performing this
function sets the global data Sum to the value of the summation from 0 to the
parameter passed to Summation().
#include <windows.h>
#include <stdio.h>
DWORD Sum; /* data is shared by the thread(s) */
/* the thread runs in this separate function */
DWORD WINAPI Summation(LPVOID Param)
{
DWORD Upper = *(DWORD*)Param;
for (DWORD i = 0; i <= Upper; i++)
Sum += i;
return 0;
}
int main(int argc, char *argv[])
{
DWORD ThreadId;
HANDLE ThreadHandle;
int Param;
if (argc != 2) {
fprintf(stderr,"An integer parameter is required\n");
return -1;
}
Param = atoi(argv[1]);
if (Param < 0) {
fprintf(stderr,"An integer >= 0 is required\n");
return -1;
}
/* create the thread */
ThreadHandle = CreateThread(
NULL, /* default security attributes */
0, /* default stack size */
Summation, /* thread function */
&Param, /* parameter to thread function */
0, /* default creation flags */
&ThreadId); /* returns the thread identifier */
if (ThreadHandle != NULL) {
/* now wait for the thread to finish */
WaitForSingleObject(ThreadHandle,INFINITE);
/* close the thread handle */
CloseHandle(ThreadHandle);
printf("sum = %d\n",Sum);
}
}
F
Threads are created in the Windows API using the CreateThread()
function, and—just as in Pthreads—a set of attributes for the thread is passed
to this function. These attributes include security information, the size of the
stack, and a flag that can be set to indicate if the thread is to start in a suspended
state. In this program, we use the default values for these attributes. (The
default values do not initially set the thread to a suspended state and instead
make it eligible to be run by the CPU scheduler.) Once the summation thread
is created, the parent must wait for it to complete before outputting the value
of Sum, as the value is set by the summation thread. Recall that the Pthread
program (Figure 4.9) had the parent thread wait for the summation thread
using the pthread join() statement. We perform the equivalent of this in the
Windows API using the WaitForSingleObject() function, which causes the
creating thread to block until the summation thread has exited.
In situations that require waiting for multiple threads to complete, the
WaitForMultipleObjects() function is used. This function is passed four
parameters:
1. The number of objects to wait for
2. A pointer to the array of objects
3. A flag indicating whether all objects have been signaled
4. A timeout duration (or INFINITE)
For example, if THandles is an array of thread HANDLE objects of size N, the
parent thread can wait for all its child threads to complete with this statement:
WaitForMultipleObjects(N, THandles, TRUE, INFINITE);

Java Threads

Threads are the fundamental model of program execution in a Java program,
and the Java language and its API provide a rich set of features for the creation
and management of threads. All Java programs comprise at least a single thread
of control—even a simple Java program consisting of only a main() method
runs as a single thread in the JVM. Java threads are available on any system that
provides a JVM including Windows, Linux, and Mac OS X. The Java thread API
is available for Android applications as well.
There are two techniques for creating threads in a Java program. One
approach is to create a new class that is derived from the Thread class and
to override its run() method. An alternative—and more commonly used—
technique is to define a class that implements the Runnable interface. The
Runnable interface is defined as follows:
public interface Runnable
{
public abstract void run();
}
When a class implements Runnable, it must define a run() method. The code
implementing the run() method is what runs as a separate thread.
Figure 4.12 shows the Java version of a multithreaded program that
determines the summation of a non-negative integer. The Summation class
implements the Runnable interface. Thread creation is performed by creating
an object instance of the Thread class and passing the constructor a Runnable
object.
Creating a Thread object does not specifically create the new thread; rather,
the start() method creates the new thread. Calling the start() method for
the new object does two things:
1. It allocates memory and initializes a new thread in the JVM.
2. It calls the run() method, making the thread eligible to be run by the JVM.
(Note again that we never call the run() method directly. Rather, we call
the start() method, and it calls the run() method on our behalf.)
When the summation program runs, the JVM creates two threads. The first
is the parent thread, which starts execution in the main() method. The second
thread is created when the start() method on the Thread object is invoked.
This child thread begins execution in the run() method of the Summation class.
After outputting the value of the summation, this thread terminates when it
exits from its run() method.
Data sharing between threads occurs easily in Windows and Pthreads, since
shared data are simply declared globally. As a pure object-oriented language,
Java has no such notion of global data. If two or more threads are to share
data in a Java program, the sharing occurs by passing references to the shared
object to the appropriate threads. In the Java program shown in Figure 4.12,
the main thread and the summation thread share the object instance of the Sum
class. This shared object is referenced through the appropriate getSum() and
setSum() methods. (You might wonder why we don’t use an Integer object
rather than designing a new sum class. The reason is that the Integer class is
immutable—that is, once its value is set, it cannot change.)
Recall that the parent threads in the Pthreads and Windows libraries
use pthread join() and WaitForSingleObject() (respectively) to wait
for the summation threads to finish before proceeding. The join() method
in Java provides similar functionality. (Notice that join() can throw an
InterruptedException, which we choose to ignore.) If the parent must wait
for several threads to finish, the join() method can be enclosed in a for loop.

Implicit Threading

With the continued growth of multicore processing, applications containing
hundreds—or even thousands—of threads are looming on the horizon.
Designing such applications is not a trivial undertaking: programmers must
address not only the challenges outlined in Section 4.2 but additional difficulties
as well. These difficulties, which relate to program correctness, are covered in
Chapters 5 and 7.
One way to address these difficulties and better support the design of
multithreaded applications is to transfer the creation and management of
threading from application developers to compilers and run-time libraries.
This strategy, termed implicit threading, is a popular trend today. In this
section, we explore three alternative approaches for designing multithreaded
programs that can take advantage of multicore processors through implicit
threading.
class Sum
{
private int sum;
public int getSum() {
return sum;
}
public void setSum(int sum) {
this.sum = sum;
}
}
class Summation implements Runnable
{
private int upper;
private Sum sumValue;
public Summation(int upper, Sum sumValue) {
this.upper = upper;
this.sumValue = sumValue;
}
public void run() {
int sum = 0;
for (int i = 0; i <= upper; i++)
sum += i;
sumValue.setSum(sum);
}
}
public class Driver
{
public static void main(String[] args) {
if (args.length > 0) {
if (Integer.parseInt(args[0]) < 0)
System.err.println(args[0] + " must be >= 0.");
else {
Sum sumObject = new Sum();
int upper = Integer.parseInt(args[0]);
Thread thrd = new Thread(new Summation(upper, sumObject));
thrd.start();
try {
thrd.join();
System.out.println
("The sum of "+upper+" is "+sumObject.getSum());
} catch (InterruptedException ie) { }
}
}
else
System.err.println("Usage: Summation <integer value>"); }
}

Thread Pools

we described a multithreaded web server. In this situation,
whenever the server receives a request, it creates a separate thread to service
the request. Whereas creating a separate thread is certainly superior to creating
a separate process, a multithreaded server nonetheless has potential problems.
The first issue concerns the amount of time required to create the thread,
together with the fact that the thread will be discarded once it has completed
its work. The second issue is more troublesome. If we allow all concurrent
requests to be serviced in a new thread, we have not placed a bound on the
number of threads concurrently active in the system. Unlimited threads could
exhaust system resources, such as CPU time or memory. One solution to this
problem is to use a thread pool.
The general idea behind a thread pool is to create a number of threads at
process startup and place them into a pool, where they sit and wait for work.
When a server receives a request, it awakens a thread from this pool—if one
is available—and passes it the request for service. Once the thread completes
its service, it returns to the pool and awaits more work. If the pool contains no
available thread, the server waits until one becomes free
Thread pools offer these benefits:
1. Servicing a request with an existing thread is faster than waiting to create
a thread.
2. A thread pool limits the number of threads that exist at any one point.
This is particularly important on systems that cannot support a large
number of concurrent threads.
3. Separating the task to be performed from the mechanics of creating the
task allows us to use different strategies for running the task. For example,
the task could be scheduled to execute after a time delay or to execute
periodically.
The number of threads in the pool can be set heuristically based on factors
such as the number of CPUs in the system, the amount of physical memory,
and the expected number of concurrent client requests. More sophisticated
thread-pool architectures can dynamically adjust the number of threads in the
pool according to usage patterns. Such architectures provide the further benefit
of having a smaller pool—thereby consuming less memory—when the load
on the system is low. We discuss one such architecture, Apple’s Grand Central
Dispatch, later in this section.
The Windows API provides several functions related to thread pools. Using
the thread pool API is similar to creating a thread with the Thread Create()
function, as described in Section 4.4.2. Here, a function that is to run as a
separate thread is defined. Such a function may appear as follows:
DWORD WINAPI PoolFunction(AVOID Param) {
/*
* this function runs as a separate thread.
*/
}
A pointer to PoolFunction() is passed to one of the functions in the thread
pool API, and a thread from the pool executes this function. One such member
in the thread pool API is the QueueUserWorkItem() function, which is passed
three parameters:
• LPTHREAD START ROUTINE Function—a pointer to the function that is to
run as a separate thread
• PVOID Param—the parameter passed to Function
• ULONG Flags—flags indicating how the thread pool is to create and
manage execution of the thread
An example of invoking a function is the following:
QueueUserWorkItem(&PoolFunction, NULL, 0);
This causes a thread from the thread pool to invoke PoolFunction() on behalf
of the programmer. In this instance, we pass no parameters to PoolFunction()
Because we specify 0 as a flag, we provide the thread pool with no
special instructions for thread creation.
Other members in the Windows thread pool API include utilities that invoke
functions at periodic intervals or when an asynchronous I/O request completes.
The java.util.concurrent package in the Java API provides a thread-pool
utility as well.

OpenMP

OpenMP is a set of compiler directives as well as an API for programs written
in C, C++, or FORTRAN that provides support for parallel programming in
shared-memory environments. OpenMP identifies parallel regions as blocks
of code that may run in parallel. Application developers insert compiler
directives into their code at parallel regions, and these directives instruct the
OpenMP run-time library to execute the region in parallel. The following C
program illustrates a compiler directive above the parallel region containing
the printf() statement:
#include <omp.h>
#include <stdio.h>
int main(int argc, char *argv[])
{
/* sequential code */
#pragma omp parallel
{
printf("I am a parallel region.");
}
/* sequential code */
return 0;
}
When OpenMP encounters the directive
#pragma omp parallel
it creates as many threads are there are processing cores in the system. Thus, for
a dual-core system, two threads are created, for a quad-core system, four are
created; and so forth. All the threads then simultaneously execute the parallel
region. As each thread exits the parallel region, it is terminated.
OpenMP provides several additional directives for running code regions
in parallel, including parallelizing loops. For example, assume we have two
arrays a and b of size N. We wish to sum their contents and place the results
in array c. We can have this task run in parallel by using the following code
segment, which contains the compiler directive for parallelizing for loops:
#pragma omp parallel for
for (i = 0; i < N; i++) {
c[i] = a[i] + b[i];
}
OpenMP divides the work contained in the for loop among the threads it has
created in response to the directive
#pragma omp parallel for
In addition to providing directives for parallelization, OpenMP allows developers to choose among several levels of parallelism. For example, they can set
the number of threads manually. It also allows developers to identify whether
data are shared between threads or are private to a thread. OpenMP is available
on several open-source and commercial compilers for Linux, Windows, and
Mac OS X systems. We encourage readers interested in learning more about
OpenMP to consult the bibliography at the end of the chapter

Grand Central Dispatch

Grand Central Dispatch (GCD)—a technology for Apple’s Mac OS X and iOS
operating systems—is a combination of extensions to the C language, an API,
and a run-time library that allows application developers to identify sections
of code to run in parallel. Like OpenMP, GCD manages most of the details of
threading.
GCD identifies extensions to the C and C++ languages known as blocks. A
block is simply a self-contained unit of work. It is specified by a caret ˆ inserted
in front of a pair of braces { }. A simple example of a block is shown below:
ˆ{ printf("I am a block"); }
GCD schedules blocks for run-time execution by placing them on a dispatch
queue. When it removes a block from a queue, it assigns the block to an
available thread from the thread pool it manages. GCD identifies two types of
dispatch queues: serial and concurrent.
Blocks placed on a serial queue are removed in FIFO order. Once a block has
been removed from the queue, it must complete execution before another block
is removed. Each process has its own serial queue (known as its main queue).
Developers can create additional serial queues that are local to particular
processes. Serial queues are useful for ensuring the sequential execution of
several tasks.
Blocks placed on a concurrent queue are also removed in FIFO order, but
several blocks may be removed at a time, thus allowing multiple blocks to
execute in parallel. There are three system-wide concurrent dispatch queues,
and they are distinguished according to priority: low, default, and high.
Priorities represent an approximation of the relative importance of blocks.
Quite simply, blocks with a higher priority should be placed on the highpriority dispatch queue.
The following code segment illustrates obtaining the default-priority
concurrent queue and submitting a block to the queue using the
dispatch async() function:
dispatch queue t queue = dispatch get global queue
(DISPATCH QUEUE PRIORITY DEFAULT, 0);
dispatch async(queue, ˆ{ printf("I am a block."); });
Internally, GCD’s thread pool is composed of POSIX threads. GCD actively
manages the pool, allowing the number of threads to grow and shrink
according to application demand and system capacity.


Other Approaches

Thread pools, OpenMP, and Grand Central Dispatch are just a few of many
emerging technologies for managing multithreaded applications. Other commercial approaches include parallel and concurrent libraries, such as Intel’s
Threading Building Blocks (TBB) and several products from Microsoft. The Java
language and API have seen significant movement toward supporting concurrent programming as well. A notable example is the java.util.concurrent
package, which supports implicit thread creation and management.

Threading Issues

In this section, we discuss some of the issues to consider in designing
multithreaded programs.

The fork() and exec() System Calls

In Chapter 3, we described how the fork() system call is used to create a
separate, duplicate process. The semantics of the fork() and exec() system
calls change in a multithreaded program.
If one thread in a program calls fork(), does the new process duplicate
all threads, or is the new process single-threaded? Some UNIX systems have
chosen to have two versions of fork(), one that duplicates all threads and
another that duplicates only the thread that invoked the fork() system call.
The exec() system call typically works in the same way as described
in Chapter 3. That is, if a thread invokes the exec() system call, the program
specified in the parameter to exec() will replace the entire process—including
all threads.
Which of the two versions of fork() to use depends on the application.
If exec() is called immediately after forking, then duplicating all threads is
unnecessary, as the program specified in the parameters to exec() will replace
the process. In this instance, duplicating only the calling thread is appropriate.
If, however, the separate process does not call exec() after forking, the separate
process should duplicate all threads

Signal Handling

A signal is used in UNIX systems to notify a process that a particular event has
occurred. A signal may be received either synchronously or asynchronously
depending on the source of and the reason for the event being signaled. All
signals, whether synchronous or asynchronous, follow the same pattern:
1. A signal is generated by the occurrence of a particular event.
2. The signal is delivered to a process.
3. Once delivered, the signal must be handled.
Examples of synchronous signal include illegal memory access and division by 0. If a running program performs either of these actions, a signal
is generated. Synchronous signals are delivered to the same process that
performed the operation that caused the signal (that is the reason they are
considered synchronous).
When a signal is generated by an event external to a running process, that
process receives the signal asynchronously. Examples of such signals include
terminating a process with specific keystrokes (such as <control><C>) and
having a timer expire. Typically, an asynchronous signal is sent to another
process.
A signal may be handled by one of two possible handlers:
1. A default signal handler
2. A user-defined signal handler
Every signal has a default signal handler that the kernel runs when
handling that signal. This default action can be overridden by a user-defined
signal handler that is called to handle the signal. Signals are handled in
different ways. Some signals (such as changing the size of a window) are
simply ignored; others (such as an illegal memory access) are handled by
terminating the program.
Handling signals in single-threaded programs is straightforward: signals
are always delivered to a process. However, delivering signals is more
complicated in multithreaded programs, where a process may have several
threads. Where, then, should a signal be delivered?
In general, the following options exist:
1. Deliver the signal to the thread to which the signal applies.
2. Deliver the signal to every thread in the process.
3. Deliver the signal to certain threads in the process.
4. Assign a specific thread to receive all signals for the process.
The method for delivering a signal depends on the type of signal generated.
For example, synchronous signals need to be delivered to the thread causing
the signal and not to other threads in the process. However, the situation with
asynchronous signals is not as clear. Some asynchronous signals—such as a
signal that terminates a process (<control><C>, for example)—should be
sent to all threads
The standard UNIX function for delivering a signal is
kill(pid t pid, int signal)
This function specifies the process (pid) to which a particular signal (signal) is
to be delivered. Most multithreaded versions of UNIX allow a thread to specify
which signals it will accept and which it will block. Therefore, in some cases,
an asynchronous signal may be delivered only to those threads that are not
blocking it. However, because signals need to be handled only once, a signal is
typically delivered only to the first thread found that is not blocking it. POSIX
Pthreads provides the following function, which allows a signal to be delivered
to a specified thread (tid):
pthread kill(pthread t tid, int signal)
Although Windows does not explicitly provide support for signals, it
allows us to emulate them using asynchronous procedure calls (APCs). The
APC facility enables a user thread to specify a function that is to be called
when the user thread receives notification of a particular event. As indicated
by its name, an APC is roughly equivalent to an asynchronous signal in UNIX.
However, whereas UNIX must contend with how to deal with signals in a
multithreaded environment, the APC facility is more straightforward, since an
APC is delivered to a particular thread rather than a process

Thread Cancellation

Thread cancellation involves terminating a thread before it has completed. For
example, if multiple threads are concurrently searching through a database and
one thread returns the result, the remaining threads might be canceled. Another
situation might occur when a user presses a button on a web browser that stops
a web page from loading any further. Often, a web page loads using several
threads—each image is loaded in a separate thread. When a user presses the
stop button on the browser, all threads loading the page are canceled.
A thread that is to be canceled is often referred to as the target thread.
Cancellation of a target thread may occur in two different scenarios:
1. Asynchronous cancellation. One thread immediately terminates the
target thread.
2. Deferred cancellation. The target thread periodically checks whether it
should terminate, allowing it an opportunity to terminate itself in an
orderly fashion.
The difficulty with cancellation occurs in situations where resources have
been allocated to a canceled thread or where a thread is canceled while in
the midst of updating data it is sharing with other threads. This becomes
especially troublesome with asynchronous cancellation. Often, the operating
system will reclaim system resources from a canceled thread but will not
reclaim all resources. Therefore, canceling a thread asynchronously may not
free a necessary system-wide resource.
With deferred cancellation, in contrast, one thread indicates that a target
thread is to be canceled, but cancellation occurs only after the target thread has
checked a flag to determine whether or not it should be canceled. The thread
can perform this check at a point at which it can be canceled safely.
In Pthreads, thread cancellation is initiated using the pthread cancel()
function. The identifier of the target thread is passed as a parameter to
the function. The following code illustrates creating—and then canceling—
a thread:
pthread t tid;
/* create the thread */
pthread create(&tid, 0, worker, NULL);
...
/* cancel the thread */
pthread cancel(tid);
Invoking pthread cancel()indicates only a request to cancel the target
thread, however; actual cancellation depends on how the target thread is set
up to handle the request. Pthreads supports three cancellation modes. Each
mode is defined as a state and a type, as illustrated in the table below. A thread
may set its cancellation state and type using an API
As the table illustrates, Pthreads allows threads to disable or enable
cancellation. Obviously, a thread cannot be canceled if cancellation is disabled.
However, cancellation requests remain pending, so the thread can later enable
cancellation and respond to the request.
The default cancellation type is deferred cancellation. Here, cancellation
occurs only when a thread reaches a cancellation point. One technique for
establishing a cancellation point is to invoke the pthread testcancel()
function. If a cancellation request is found to be pending, a function known
as a cleanup handler is invoked. This function allows any resources a thread
may have acquired to be released before the thread is terminated.
The following code illustrates how a thread may respond to a cancellation
request using deferred cancellation:
while (1) {
/* do some work for awhile */
/* ... */
/* check if there is a cancellation request */
pthread testcancel();
}
Because of the issues described earlier, asynchronous cancellation is not
recommended in Pthreads documentation. Thus, we do not cover it here. An
interesting note is that on Linux systems, thread cancellation using the Pthreads
API is handled through signals

Thread-Local Storage

Threads belonging to a process share the data of the process. Indeed, this
data sharing provides one of the benefits of multithreaded programming.
However, in some circumstances, each thread might need its own copy of
certain data. We will call such data thread-local storage (or TLS.) For example,
in a transaction-processing system, we might service each transaction in a
separate thread. Furthermore, each transaction might be assigned a unique
identifier. To associate each thread with its unique identifier, we could use
thread-local storage.
It is easy to confuse TLS with local variables. However, local variables
are visible only during a single function invocation, whereas TLS data are
visible across function invocations. In some ways, TLS is similar to static
data. The difference is that TLS data are unique to each thread. Most thread
libraries—including Windows and Pthreads—provide some form of support
for thread-local storage; Java provides support as well.

Scheduler Activations

A final issue to be considered with multithreaded programs concerns communication between the kernel and the thread library, which may be required
by the many-to-many and two-level models discussed in Section 4.3.3. Such
coordination allows the number of kernel threads to be dynamically adjusted
to help ensure the best performance.
Many systems implementing either the many-to-many or the two-level
model place an intermediate data structure between the user and kernel
threads. This data structure—typically known as a lightweight process, or
LWP—is shown in Figure 4.13. To the user-thread library, the LWP appears to
be a virtual processor on which the application can schedule a user thread to
run. Each LWP is attached to a kernel thread, and it is kernel threads that the
operating system schedules to run on physical processors. If a kernel thread
blocks (such as while waiting for an I/O operation to complete), the LWP blocks
as well. Up the chain, the user-level thread attached to the LWP also blocks.
An application may require any number of LWPs to run efficiently. Consider
a CPU-bound application running on a single processor. In this scenario, only
one thread can run at at a time, so one LWP is sufficient. An application that is
I/O-intensive may require multiple LWPs to execute, however. Typically, an LWP
is required for each concurrent blocking system call. Suppose, for example, that
five different file-read requests occur simultaneously. Five LWPs are needed,
because all could be waiting for I/O completion in the kernel. If a process has
only four LWPs, then the fifth request must wait for one of the LWPs to return
from the kernel.
One scheme for communication between the user-thread library and the
kernel is known as scheduler activation. It works as follows: The kernel
provides an application with a set of virtual processors (LWPs), and the
application can schedule user threads onto an available virtual processor.
Furthermore, the kernel must inform an application about certain events. This
procedure is known as an upcall. Upcalls are handled by the thread library
with an upcall handler, and upcall handlers must run on a virtual processor.
One event that triggers an upcall occurs when an application thread is about to
block. In this scenario, the kernel makes an upcall to the application informing
it that a thread is about to block and identifying the specific thread. The kernel
then allocates a new virtual processor to the application. The application runs
an upcall handler on this new virtual processor, which saves the state of the
blocking thread and relinquishes the virtual processor on which the blocking
thread is running. The upcall handler then schedules another thread that is
eligible to run on the new virtual processor. When the event that the blocking
thread was waiting for occurs, the kernel makes another upcall to the thread
library informing it that the previously blocked thread is now eligible to run.
The upcall handler for this event also requires a virtual processor, and the kernel
may allocate a new virtual processor or preempt one of the user threads and
run the upcall handler on its virtual processor. After marking the unblocked
thread as eligible to run, the application schedules an eligible thread to run on
an available virtual processor

operating system schedules to run on physical processors. If a kernel thread
blocks (such as while waiting for an I/O operation to complete), the LWP blocks
as well. Up the chain, the user-level thread attached to the LWP also blocks.
An application may require any number of LWPs to run efficiently. Consider
a CPU-bound application running on a single processor. In this scenario, only
one thread can run at at a time, so one LWP is sufficient. An application that is
I/O-intensive may require multiple LWPs to execute, however. Typically, an LWP
is required for each concurrent blocking system call. Suppose, for example, that
five different file-read requests occur simultaneously. Five LWPs are needed,
because all could be waiting for I/O completion in the kernel. If a process has
only four LWPs, then the fifth request must wait for one of the LWPs to return
from the kernel.
One scheme for communication between the user-thread library and the
kernel is known as scheduler activation. It works as follows: The kernel
provides an application with a set of virtual processors (LWPs), and the
application can schedule user threads onto an available virtual processor.
Furthermore, the kernel must inform an application about certain events. This
procedure is known as an upcall. Upcalls are handled by the thread library
with an upcall handler, and upcall handlers must run on a virtual processor.
One event that triggers an upcall occurs when an application thread is about to
block. In this scenario, the kernel makes an upcall to the application informing
it that a thread is about to block and identifying the specific thread. The kernel
then allocates a new virtual processor to the application. The application runs
an upcall handler on this new virtual processor, which saves the state of the
blocking thread and relinquishes the virtual processor on which the blocking
thread is running. The upcall handler then schedules another thread that is
eligible to run on the new virtual processor. When the event that the blocking
thread was waiting for occurs, the kernel makes another upcall to the thread
library informing it that the previously blocked thread is now eligible to run.
The upcall handler for this event also requires a virtual processor, and the kernel
may allocate a new virtual processor or preempt one of the user threads and
run the upcall handler on its virtual processor. After marking the unblocked
thread as eligible to run, the application schedules an eligible thread to run on
an available virtual processor
operating system schedules to run on physical processors. If a kernel thread
blocks (such as while waiting for an I/O operation to complete), the LWP blocks
as well. Up the chain, the user-level thread attached to the LWP also blocks.
An application may require any number of LWPs to run efficiently. Consider
a CPU-bound application running on a single processor. In this scenario, only
one thread can run at at a time, so one LWP is sufficient. An application that is
I/O-intensive may require multiple LWPs to execute, however. Typically, an LWP
is required for each concurrent blocking system call. Suppose, for example, that
five different file-read requests occur simultaneously. Five LWPs are needed,
because all could be waiting for I/O completion in the kernel. If a process has
only four LWPs, then the fifth request must wait for one of the LWPs to return
from the kernel.
One scheme for communication between the user-thread library and the
kernel is known as scheduler activation. It works as follows: The kernel
provides an application with a set of virtual processors (LWPs), and the
application can schedule user threads onto an available virtual processor.
Furthermore, the kernel must inform an application about certain events. This
procedure is known as an upcall. Upcalls are handled by the thread library
with an upcall handler, and upcall handlers must run on a virtual processor.
One event that triggers an upcall occurs when an application thread is about to
block. In this scenario, the kernel makes an upcall to the application informing
it that a thread is about to block and identifying the specific thread. The kernel
then allocates a new virtual processor to the application. The application runs
an upcall handler on this new virtual processor, which saves the state of the
blocking thread and relinquishes the virtual processor on which the blocking
thread is running. The upcall handler then schedules another thread that is
eligible to run on the new virtual processor. When the event that the blocking
thread was waiting for occurs, the kernel makes another upcall to the thread
library informing it that the previously blocked thread is now eligible to run.
The upcall handler for this event also requires a virtual processor, and the kernel
may allocate a new virtual processor or preempt one of the user threads and
run the upcall handler on its virtual processor. After marking the unblocked
thread as eligible to run, the application schedules an eligible thread to run on
an available virtual processor.

Operating-System Examples

At this point, we have examined a number of concepts and issues related to
threads. We conclude the chapter by exploring how threads are implemented
in Windows and Linux systems.

Windows Threads

Windows implements the Windows API, which is the primary API for the
family of Microsoft operating systems (Windows 98, NT, 2000, and XP, as well
as Windows 7). Indeed, much of what is mentioned in this section applies to
this entire family of operating systems.
A Windows application runs as a separate process, and each process may
contain one or more threads. The Windows API for creating threads is covered in

Section 4.4.2. Additionally, Windows uses the one-to-one mapping described
in Section 4.3.2, where each user-level thread maps to an associated kernel
thread.
The general components of a thread include:
• A thread ID uniquely identifying the thread
• A register set representing the status of the processor
• A user stack, employed when the thread is running in user mode, and a
kernel stack, employed when the thread is running in kernel mode
• A private storage area used by various run-time libraries and dynamic link
libraries (DLLs)
The register set, stacks, and private storage area are known as the context of
the thread.
The primary data structures of a thread include:
• ETHREAD—executive thread block
• KTHREAD—kernel thread block
• TEB—thread environment block
The key components of the ETHREAD include a pointer to the process
to which the thread belongs and the address of the routine in which the
thread starts control. The ETHREAD also contains a pointer to the corresponding
KTHREAD.
The KTHREAD includes scheduling and synchronization information for
the thread. In addition, the KTHREAD includes the kernel stack (used when the
thread is running in kernel mode) and a pointer to the TEB.
The ETHREAD and the KTHREAD exist entirely in kernel space; this means
that only the kernel can access them. The TEB is a user-space data structure
that is accessed when the thread is running in user mode. Among other fields,
the TEB contains the thread identifier, a user-mode stack, and an array for
thread-local storage

Linux Threads

Linux provides the fork() system call with the traditional functionality of
duplicating a process, as described in Chapter 3. Linux also provides the ability
to create threads using the clone() system call. However, Linux does not
distinguish between processes and threads. In fact, Linux uses the term task
srather than process or thread— when referring to a flow of control within a
program.
When clone() is invoked, it is passed a set of flags that determine how
much sharing is to take place between the parent and child tasks. Some of these
flags are listed in Figure 4.15. For example, suppose that clone() is passed
the flags CLONE FS, CLONE VM, CLONE SIGHAND, and CLONE FILES. The parent
and child tasks will then share the same file-system information (such as the
current working directory), the same memory space, the same signal handlers
and the same set of open files. Using clone() in this fashion is equivalent to
creating a thread as described in this chapter, since the parent task shares most
of its resources with its child task. However, if none of these flags is set when
clone() is invoked, no sharing takes place, resulting in functionality similar
to that provided by the fork() system call.
The varying level of sharing is possible because of the way a task is
represented in the Linux kernel. A unique kernel data structure (specifically,
struct task struct) exists for each task in the system. This data structure,
instead of storing data for the task, contains pointers to other data structures
where these data are stored—for example, data structures that represent the list
of open files, signal-handling information, and virtual memory. When fork()
is invoked, a new task is created, along with a copy of all the associated data
structures of the parent process. A new task is also created when the clone()
system call is made. However, rather than copying all data structures, the new
task points to the data structures of the parent task, depending on the set of
flags passed to clone()
